#!/usr/bin/env bash
set -euo pipefail

# NexoWattVPN Root Helper
# This script is intended to be executed via sudo by the ioBroker adapter.
# Keep this script minimal and auditable. Do not add generic command execution.

HELPER_VERSION="0.0.1"

SETUP_VARS="/etc/pivpn/wireguard/setupVars.conf"
WG_CONF="/etc/wireguard/wg0.conf"
CLIENTS_TXT="/etc/wireguard/configs/clients.txt"
CLIENTS_DIR="/etc/wireguard/configs"

CHAIN_IN="NEXOWATTVPN_IN"
CHAIN_FWD="NEXOWATTVPN_FWD"

err() {
  echo "[$(date +'%Y-%m-%dT%H:%M:%S%z')]: $*" >&2
}

die() {
  err "$*"
  exit 1
}

need_root() {
  if [[ "${EUID}" -ne 0 ]]; then
    die "This helper must run as root (use sudo)."
  fi
}

have_cmd() {
  command -v "$1" >/dev/null 2>&1
}

safe_name() {
  local name="$1"
  # PiVPN allows a-zA-Z0-9 and .-@_ (see makeCONF.sh)
  [[ "${name}" =~ ^[a-zA-Z0-9.@_-]{1,32}$ ]] || return 1
  [[ "${name}" != "server" ]] || return 1
  return 0
}

strip_quotes() {
  local s="$1"
  s="${s%\"}"
  s="${s#\"}"
  echo "${s}"
}

read_var() {
  local key="$1"
  local file="$2"
  local line
  line="$(grep -E "^${key}=" "${file}" | tail -n 1 || true)"
  if [[ -z "${line}" ]]; then
    echo ""
    return 0
  fi
  echo "$(strip_quotes "${line#*=}")"
}

ipv4_to_dec() {
  local ip="$1"
  IFS='.' read -r a b c d <<< "${ip}"
  echo "$(( (a<<24) + (b<<16) + (c<<8) + d ))"
}

dec_to_ipv4() {
  local dec="$1"
  local a=$(( (dec >> 24) & 255 ))
  local b=$(( (dec >> 16) & 255 ))
  local c=$(( (dec >> 8) & 255 ))
  local d=$(( dec & 255 ))
  echo "${a}.${b}.${c}.${d}"
}

compute_server_ip() {
  local net="$1"
  local netdec
  netdec="$(ipv4_to_dec "${net}")"
  dec_to_ipv4 "$((netdec + 1))"
}

set_var_in_file() {
  local key="$1"
  local value="$2"
  local file="$3"

  # Escape backslashes and ampersands for sed replacement
  local esc
  esc="$(printf '%s' "${value}" | sed -e 's/[\/&]/\\&/g')"

  if grep -qE "^${key}=" "${file}"; then
    sed -i -E "s/^${key}=.*/${key}=${esc}/" "${file}"
  else
    printf '%s=%s\n' "${key}" "${value}" >> "${file}"
  fi
}

update_wg_listen_port() {
  local port="$1"
  if [[ ! -f "${WG_CONF}" ]]; then
    return 0
  fi
  if grep -qE '^ListenPort\s*=' "${WG_CONF}"; then
    sed -i -E "s/^ListenPort\s*=.*/ListenPort = ${port}/" "${WG_CONF}"
  else
    # Insert after [Interface] block header if possible
    awk -v port="${port}" '
      BEGIN { inserted=0 }
      {
        print $0
        if (!inserted && $0 ~ /^\[Interface\]/) {
          # try to insert after next line (PrivateKey usually)
          # but keep simple: insert immediately if no ListenPort exists
        }
      }
      END {}
    ' "${WG_CONF}" >/dev/null 2>&1 || true
    # Append as fallback
    printf '\nListenPort = %s\n' "${port}" >> "${WG_CONF}"
  fi
}

restart_wg_service() {
  local wgIf="$1"
  if have_cmd systemctl; then
    systemctl restart "wg-quick@${wgIf}.service" >/dev/null 2>&1 || systemctl restart "wg-quick@${wgIf}" >/dev/null 2>&1 || true
  fi
}

cmd_status() {
  local pivpnInstalled=false
  local pivpnPath=""
  local wireguardConfigured=false

  if have_cmd pivpn; then
    pivpnInstalled=true
    pivpnPath="$(command -v pivpn)"
  fi

  if [[ -f "${SETUP_VARS}" ]]; then
    wireguardConfigured=true
  fi

  local wgInterface=""
  local pivpnNET=""
  local subnetClass=""
  local pivpnHOST=""
  local pivpnPORT=""
  local allowedIps=""
  local serverIp=""

  if [[ "${wireguardConfigured}" == "true" ]]; then
    wgInterface="$(read_var "pivpnDEV" "${SETUP_VARS}")"
    pivpnNET="$(read_var "pivpnNET" "${SETUP_VARS}")"
    subnetClass="$(read_var "subnetClass" "${SETUP_VARS}")"
    pivpnHOST="$(read_var "pivpnHOST" "${SETUP_VARS}")"
    pivpnPORT="$(read_var "pivpnPORT" "${SETUP_VARS}")"
    allowedIps="$(read_var "ALLOWED_IPS" "${SETUP_VARS}")"
    if [[ -n "${pivpnNET}" ]]; then
      serverIp="$(compute_server_ip "${pivpnNET}")"
    fi
  fi

  local wgActive=false
  if [[ -n "${wgInterface}" ]] && have_cmd systemctl; then
    if systemctl is-active --quiet "wg-quick@${wgInterface}.service" || systemctl is-active --quiet "wg-quick@${wgInterface}"; then
      wgActive=true
    fi
  fi

  python3 - <<PY
import json
print(json.dumps({
  "helperVersion": "${HELPER_VERSION}",
  "pivpnInstalled": ${pivpnInstalled},
  "pivpnPath": "${pivpnPath}",
  "wireguardConfigured": ${wireguardConfigured},
  "wgInterface": "${wgInterface}",
  "pivpnNET": "${pivpnNET}",
  "subnetClass": "${subnetClass}",
  "pivpnHOST": "${pivpnHOST}",
  "pivpnPORT": "${pivpnPORT}",
  "ALLOWED_IPS": "${allowedIps}",
  "serverIp": "${serverIp}",
  "wgActive": ${wgActive}
}, ensure_ascii=False))
PY
}

cmd_configure() {
  [[ -f "${SETUP_VARS}" ]] || die "Missing ${SETUP_VARS}. PiVPN/WireGuard not configured."

  local endpointHost=""
  local port=""
  local dns1=""
  local dns2=""
  local allowedIps=""

  while [[ "$#" -gt 0 ]]; do
    case "$1" in
      --endpoint-host)
        endpointHost="${2:-}"; shift 2;;
      --port)
        port="${2:-}"; shift 2;;
      --dns1)
        dns1="${2:-}"; shift 2;;
      --dns2)
        dns2="${2:-}"; shift 2;;
      --allowed-ips)
        allowedIps="${2:-}"; shift 2;;
      --json)
        shift 1;;
      *)
        die "Unknown argument for configure: $1";;
    esac
  done

  local pivpnNET
  pivpnNET="$(read_var "pivpnNET" "${SETUP_VARS}")"
  local wgIf
  wgIf="$(read_var "pivpnDEV" "${SETUP_VARS}")"
  [[ -n "${wgIf}" ]] || wgIf="wg0"

  if [[ -n "${endpointHost}" ]]; then
    set_var_in_file "pivpnHOST" "\"${endpointHost}\"" "${SETUP_VARS}"
  fi

  if [[ -n "${port}" ]]; then
    [[ "${port}" =~ ^[0-9]+$ ]] || die "Port is not numeric"
    (( port >= 1 && port <= 65535 )) || die "Port out of range"
    set_var_in_file "pivpnPORT" "${port}" "${SETUP_VARS}"
    update_wg_listen_port "${port}"
  fi

  if [[ -n "${dns1}" ]]; then
    set_var_in_file "pivpnDNS1" "\"${dns1}\"" "${SETUP_VARS}"
  fi
  if [[ -n "${dns2}" ]]; then
    set_var_in_file "pivpnDNS2" "\"${dns2}\"" "${SETUP_VARS}"
  fi

  if [[ -n "${allowedIps}" ]]; then
    if [[ "${allowedIps}" == "HOST_ONLY" || "${allowedIps}" == "HOST_ONLY" ]]; then
      [[ -n "${pivpnNET}" ]] || die "pivpnNET missing in setupVars.conf"
      local serverIp
      serverIp="$(compute_server_ip "${pivpnNET}")"
      allowedIps="${serverIp}/32"
    fi
    set_var_in_file "ALLOWED_IPS" "\"${allowedIps}\"" "${SETUP_VARS}"
  fi

  restart_wg_service "${wgIf}"

  # Return applied values
  local pivpnHOST pivpnPORT ALLOWED_IPS serverIp
  pivpnHOST="$(read_var "pivpnHOST" "${SETUP_VARS}")"
  pivpnPORT="$(read_var "pivpnPORT" "${SETUP_VARS}")"
  ALLOWED_IPS="$(read_var "ALLOWED_IPS" "${SETUP_VARS}")"
  serverIp=""
  if [[ -n "${pivpnNET}" ]]; then
    serverIp="$(compute_server_ip "${pivpnNET}")"
  fi

  python3 - <<PY
import json
print(json.dumps({
  "ok": True,
  "pivpnHOST": "${pivpnHOST}",
  "pivpnPORT": "${pivpnPORT}",
  "ALLOWED_IPS": "${ALLOWED_IPS}",
  "serverIp": "${serverIp}",
  "wgInterface": "${wgIf}"
}, ensure_ascii=False))
PY
}

cmd_list_peers() {
  [[ -f "${CLIENTS_TXT}" ]] || python3 - <<PY
import json
print(json.dumps({"peers": []}, ensure_ascii=False))
PY
  [[ -f "${CLIENTS_TXT}" ]] || return 0

  local wgIf
  wgIf="$(read_var "pivpnDEV" "${SETUP_VARS}")"
  [[ -n "${wgIf}" ]] || wgIf="wg0"

  python3 - <<'PY'
import json, re, pathlib, ipaddress

clients_txt = pathlib.Path("/etc/wireguard/configs/clients.txt")
wg_conf = pathlib.Path("/etc/wireguard/wg0.conf")

disabled = set()
try:
    txt = wg_conf.read_text(errors="ignore")
    for m in re.finditer(r"#\[disabled\]\s+###\s+begin\s+([^\s]+)\s+###", txt):
        disabled.add(m.group(1))
except FileNotFoundError:
    pass

peers = []
if clients_txt.exists():
    for line in clients_txt.read_text(errors="ignore").splitlines():
        if not line.strip():
            continue
        parts = line.split()
        if len(parts) < 4:
            continue
        name, pub, created, ipdec = parts[0], parts[1], parts[2], parts[3]
        try:
            ip = str(ipaddress.IPv4Address(int(ipdec)))
        except Exception:
            ip = ""
        peers.append({
            "name": name,
            "publicKey": pub,
            "createdAt": int(created) if created.isdigit() else None,
            "ipDec": int(ipdec) if ipdec.isdigit() else None,
            "ip": ip,
            "disabled": name in disabled
        })

print(json.dumps({"peers": peers}, ensure_ascii=False))
PY
}

cmd_add_peer() {
  local name=""
  local ip="auto"
  while [[ "$#" -gt 0 ]]; do
    case "$1" in
      --name) name="${2:-}"; shift 2;;
      --ip) ip="${2:-auto}"; shift 2;;
      --json) shift 1;;
      *) die "Unknown argument for add-peer: $1";;
    esac
  done

  [[ -n "${name}" ]] || die "Missing --name"
  safe_name "${name}" || die "Invalid peer name"
  [[ "${#name}" -le 15 ]] || die "Peer name must be <= 15 characters (PiVPN limit)"

  have_cmd pivpn || die "pivpn not found"
  [[ -f "${SETUP_VARS}" ]] || die "Missing ${SETUP_VARS}. PiVPN/WireGuard not configured."

  pivpn wg add --name "${name}" --client-ip "${ip}" >/dev/null

  python3 - <<PY
import json
print(json.dumps({"ok": True, "name": "${name}"}))
PY
}

cmd_remove_peer() {
  local name=""
  local yes=false
  while [[ "$#" -gt 0 ]]; do
    case "$1" in
      --name) name="${2:-}"; shift 2;;
      --yes) yes=true; shift 1;;
      --json) shift 1;;
      *) die "Unknown argument for remove-peer: $1";;
    esac
  done
  [[ -n "${name}" ]] || die "Missing --name"
  safe_name "${name}" || die "Invalid peer name"
  have_cmd pivpn || die "pivpn not found"

  if [[ "${yes}" == "true" ]]; then
    pivpn wg remove --yes "${name}" >/dev/null
  else
    pivpn wg remove "${name}"
  fi

  python3 - <<PY
import json
print(json.dumps({"ok": True, "name": "${name}"}))
PY
}

cmd_disable_peer() {
  local name=""
  local yes=false
  while [[ "$#" -gt 0 ]]; do
    case "$1" in
      --name) name="${2:-}"; shift 2;;
      --yes) yes=true; shift 1;;
      --json) shift 1;;
      *) die "Unknown argument for disable-peer: $1";;
    esac
  done
  [[ -n "${name}" ]] || die "Missing --name"
  safe_name "${name}" || die "Invalid peer name"
  have_cmd pivpn || die "pivpn not found"
  if [[ "${yes}" == "true" ]]; then
    pivpn wg off --yes "${name}" >/dev/null
  else
    pivpn wg off "${name}"
  fi
  python3 - <<PY
import json
print(json.dumps({"ok": True, "name": "${name}"}))
PY
}

cmd_enable_peer() {
  local name=""
  local yes=false
  while [[ "$#" -gt 0 ]]; do
    case "$1" in
      --name) name="${2:-}"; shift 2;;
      --yes) yes=true; shift 1;;
      --json) shift 1;;
      *) die "Unknown argument for enable-peer: $1";;
    esac
  done
  [[ -n "${name}" ]] || die "Missing --name"
  safe_name "${name}" || die "Invalid peer name"
  have_cmd pivpn || die "pivpn not found"
  if [[ "${yes}" == "true" ]]; then
    pivpn wg on --yes "${name}" >/dev/null
  else
    pivpn wg on "${name}"
  fi
  python3 - <<PY
import json
print(json.dumps({"ok": True, "name": "${name}"}))
PY
}

cmd_get_peer_conf() {
  local name=""
  while [[ "$#" -gt 0 ]]; do
    case "$1" in
      --name) name="${2:-}"; shift 2;;
      *) die "Unknown argument for get-peer-conf: $1";;
    esac
  done
  [[ -n "${name}" ]] || die "Missing --name"
  safe_name "${name}" || die "Invalid peer name"

  local file="${CLIENTS_DIR}/${name}.conf"
  [[ -f "${file}" ]] || die "Peer config not found: ${file}"
  cat "${file}"
}

cmd_apply_firewall() {
  local cfgPath=""
  while [[ "$#" -gt 0 ]]; do
    case "$1" in
      --config) cfgPath="${2:-}"; shift 2;;
      --json) shift 1;;
      *) die "Unknown argument for apply-firewall: $1";;
    esac
  done
  [[ -n "${cfgPath}" ]] || die "Missing --config"

  # Restrict config path to common ioBroker data directories
  local real
  real="$(realpath -m "${cfgPath}")"
  case "${real}" in
    /opt/iobroker/iobroker-data/*|/home/iobroker/iobroker-data/*)
      ;;
    *)
      die "Config path not allowed: ${real}"
      ;;
  esac

  NEXOWATTVPN_CFG_PATH="${real}" python3 - <<PY
import json, pathlib, subprocess, re, ipaddress, sys, os

cfg_path = pathlib.Path(os.environ["NEXOWATTVPN_CFG_PATH"])
cfg = json.loads(cfg_path.read_text())

roles_file = pathlib.Path(cfg.get("rolesFile", ""))
service_ports = cfg.get("servicePortsTcp", "")
customer_ports = cfg.get("customerPortsTcp", "")
block_forward = bool(cfg.get("blockForwarding", True))
allow_ping = bool(cfg.get("allowPing", False))

def parse_ports(val):
    if isinstance(val, list):
        ports = val
    else:
        ports = [p.strip() for p in str(val).split(",") if p.strip()]
    out = []
    for p in ports:
        try:
            pi = int(p)
        except Exception:
            raise ValueError(f"Invalid port: {p}")
        if pi < 1 or pi > 65535:
            raise ValueError(f"Port out of range: {pi}")
        out.append(pi)
    return sorted(set(out))

service_ports = parse_ports(service_ports)
customer_ports = parse_ports(customer_ports)

# Read setupVars for interface
setup_vars = pathlib.Path("/etc/pivpn/wireguard/setupVars.conf")
wg_if = "wg0"
if setup_vars.exists():
    for line in setup_vars.read_text(errors="ignore").splitlines():
        if line.startswith("pivpnDEV="):
            wg_if = line.split("=",1)[1].strip().strip('"')
            break

if not re.fullmatch(r"[a-zA-Z0-9_.-]{1,15}", wg_if):
    raise ValueError(f"Invalid wg interface: {wg_if}")

# Read roles
roles = {}
if roles_file and roles_file.exists():
    try:
        rj = json.loads(roles_file.read_text())
        for name, meta in (rj.get("peers") or {}).items():
            role = (meta.get("role") or "customer").lower()
            roles[name] = "service" if role == "service" else "customer"
    except Exception:
        roles = {}

# Read peers from clients.txt
clients_txt = pathlib.Path("/etc/wireguard/configs/clients.txt")
peers = []
if clients_txt.exists():
    for line in clients_txt.read_text(errors="ignore").splitlines():
        parts = line.split()
        if len(parts) < 4:
            continue
        name, ipdec = parts[0], parts[3]
        try:
            ip = str(ipaddress.IPv4Address(int(ipdec)))
        except Exception:
            continue
        role = roles.get(name, "customer")
        peers.append((name, ip, role))

def run(cmd):
    p = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    return p.returncode, p.stdout.strip(), p.stderr.strip()

def ensure_chain(chain):
    rc,_,_ = run(["iptables","-nL",chain])
    if rc != 0:
        rc,_,err = run(["iptables","-N",chain])
        if rc != 0:
            raise RuntimeError(f"iptables -N {chain} failed: {err}")

def flush_chain(chain):
    run(["iptables","-F",chain])

def ensure_jump(chain, base, args):
    rc,_,_ = run(["iptables","-C",base] + args + ["-j", chain])
    if rc != 0:
        # insert at top
        run(["iptables","-I",base,"1"] + args + ["-j", chain])

def delete_jump(chain, base, args):
    # delete all occurrences
    while True:
        rc,_,_ = run(["iptables","-D",base] + args + ["-j", chain])
        if rc != 0:
            break

def delete_chain(chain):
    run(["iptables","-F",chain])
    run(["iptables","-X",chain])

# Apply INPUT chain
ensure_chain("${CHAIN_IN}")
flush_chain("${CHAIN_IN}")

# Accept established/related
run(["iptables","-A","${CHAIN_IN}","-m","conntrack","--ctstate","ESTABLISHED,RELATED","-j","ACCEPT"])

if allow_ping:
    run(["iptables","-A","${CHAIN_IN}","-i",wg_if,"-p","icmp","-j","ACCEPT"])

# Per-peer allowlist
service_count = 0
customer_count = 0
rule_count = 0

for name, ip, role in peers:
    ports = service_ports if role == "service" else customer_ports
    if role == "service":
        service_count += 1
    else:
        customer_count += 1
    for port in ports:
        run(["iptables","-A","${CHAIN_IN}","-i",wg_if,"-s",ip,"-p","tcp","--dport",str(port),"-j","ACCEPT"])
        rule_count += 1

# Default deny on wg interface
run(["iptables","-A","${CHAIN_IN}","-i",wg_if,"-j","DROP"])

# Jump from INPUT for wg interface
ensure_jump("${CHAIN_IN}", "INPUT", ["-i", wg_if])

# Block forwarding to protect customer LAN
if block_forward:
    ensure_chain("${CHAIN_FWD}")
    flush_chain("${CHAIN_FWD}")
    run(["iptables","-A","${CHAIN_FWD}","-j","DROP"])
    ensure_jump("${CHAIN_FWD}", "FORWARD", ["-i", wg_if])
    ensure_jump("${CHAIN_FWD}", "FORWARD", ["-o", wg_if])

print(json.dumps({
    "ok": True,
    "wgInterface": wg_if,
    "peers": len(peers),
    "servicePeers": service_count,
    "customerPeers": customer_count,
    "portRules": rule_count,
    "servicePortsTcp": service_ports,
    "customerPortsTcp": customer_ports,
    "blockForwarding": block_forward
}, ensure_ascii=False))
PY
}

cmd_clear_firewall() {
  python3 - <<PY
import json, subprocess, pathlib, re

def run(cmd):
    p = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    return p.returncode

def delete_jump(chain, base, args):
    while True:
        rc = run(["iptables","-D",base] + args + ["-j", chain])
        if rc != 0:
            break

def delete_chain(chain):
    run(["iptables","-F",chain])
    run(["iptables","-X",chain])

# Determine wg interface from setupVars (fallback wg0)
wg_if = "wg0"
setup_vars = pathlib.Path("/etc/pivpn/wireguard/setupVars.conf")
if setup_vars.exists():
    for line in setup_vars.read_text(errors="ignore").splitlines():
        if line.startswith("pivpnDEV="):
            wg_if = line.split("=",1)[1].strip().strip('"')
            break
if not re.fullmatch(r"[a-zA-Z0-9_.-]{1,15}", wg_if):
    wg_if = "wg0"

# remove jump rules for wg interface
delete_jump("${CHAIN_IN}", "INPUT", ["-i", wg_if])
delete_jump("${CHAIN_FWD}", "FORWARD", ["-i", wg_if])
delete_jump("${CHAIN_FWD}", "FORWARD", ["-o", wg_if])

# also try wg0 as a conservative fallback
if wg_if != "wg0":
    delete_jump("${CHAIN_IN}", "INPUT", ["-i", "wg0"])
    delete_jump("${CHAIN_FWD}", "FORWARD", ["-i", "wg0"])
    delete_jump("${CHAIN_FWD}", "FORWARD", ["-o", "wg0"])

# remove chains if present
delete_chain("${CHAIN_IN}")
delete_chain("${CHAIN_FWD}")

print(json.dumps({"ok": True}, ensure_ascii=False))
PY
}

show_help() {
  cat <<EOF
NexoWattVPN root helper (${HELPER_VERSION})

Usage:
  nexowattvpn-helper status --json
  nexowattvpn-helper configure [--endpoint-host <host>] [--port <1-65535>] [--dns1 <ip>] [--dns2 <ip>] [--allowed-ips <value|HOST_ONLY>] --json
  nexowattvpn-helper list-peers --json
  nexowattvpn-helper add-peer --name <name> [--ip auto] --json
  nexowattvpn-helper remove-peer --name <name> [--yes] --json
  nexowattvpn-helper disable-peer --name <name> [--yes] --json
  nexowattvpn-helper enable-peer --name <name> [--yes] --json
  nexowattvpn-helper get-peer-conf --name <name>
  nexowattvpn-helper apply-firewall --config <path-to-firewall.json> --json
  nexowattvpn-helper clear-firewall --json
EOF
}

main() {
  need_root
  local cmd="${1:-}"
  shift || true

  case "${cmd}" in
    status)
      cmd_status "$@"
      ;;
    configure)
      cmd_configure "$@"
      ;;
    list-peers)
      cmd_list_peers "$@"
      ;;
    add-peer)
      cmd_add_peer "$@"
      ;;
    remove-peer)
      cmd_remove_peer "$@"
      ;;
    disable-peer)
      cmd_disable_peer "$@"
      ;;
    enable-peer)
      cmd_enable_peer "$@"
      ;;
    get-peer-conf)
      cmd_get_peer_conf "$@"
      ;;
    apply-firewall)
      cmd_apply_firewall "$@"
      ;;
    clear-firewall)
      cmd_clear_firewall "$@"
      ;;
    -h|--help|help|"")
      show_help
      ;;
    *)
      die "Unknown command: ${cmd}"
      ;;
  esac
}

main "$@"
